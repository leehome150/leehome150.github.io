<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>mobx 和 mobx-react 入门</title>
    <url>/posts/e13966ac/</url>
    <content><![CDATA[<h2 id="1-为什么需要状态管理？"><a href="#1-为什么需要状态管理？" class="headerlink" title="1.为什么需要状态管理？"></a>1.为什么需要状态管理？</h2><h3 id="组件内"><a href="#组件内" class="headerlink" title="组件内"></a>组件内</h3><ul>
<li>class 组件 state</li>
<li>函数组件 useState</li>
</ul>
<h3 id="组件间"><a href="#组件间" class="headerlink" title="组件间"></a>组件间</h3><ul>
<li>父子之间通信用 props 传递</li>
<li>爷孙之间通信传递两次 props</li>
<li>但是任意组件？</li>
</ul>
<p>这个时候我们就需要用到 mobx 和 mobx-react（这里不讲 redux）</p>
<h2 id="2-mobx"><a href="#2-mobx" class="headerlink" title="2.mobx"></a>2.mobx</h2><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/7/173270ed17dabb91~tplv-t2oaga2asx-image.image"></p>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p><a href="https://cn.mobx.js.org/">mobx 中文文档</a></p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ul>
<li>State</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; observable, computed, action, autorun &#125; from &quot;mobx&quot;;</span><br><span class="line">//State，被观察者</span><br><span class="line">const todos = (observable([</span><br><span class="line"> &#123;</span><br><span class="line"> title: &quot;起床&quot;,</span><br><span class="line"> completed: false</span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line"> title: &quot;穿⾐&quot;,</span><br><span class="line"> completed: false</span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line"> title: &quot;洗漱&quot;,</span><br><span class="line"> completed: false</span><br><span class="line"> &#125;</span><br><span class="line">]));</span><br></pre></td></tr></table></figure>

<ul>
<li>Computed</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Computed values ,由 State 的更新触发</span><br><span class="line">let uncompletedCount = computed(</span><br><span class="line">() =&gt; todos.filter(todo =&gt; !todo.completed).length</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>Reactions</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Reactions， 由 State 和 Computed Values 的改变触发执⾏</span><br><span class="line">autorun(() =&gt; &#123;</span><br><span class="line">console.log(</span><br><span class="line">`剩余任务:$&#123;uncompletedCount&#125;`,</span><br><span class="line">todos</span><br><span class="line">.filter(todo =&gt; !todo.completed)</span><br><span class="line">.map(todo =&gt; todo.title)</span><br><span class="line">.join(&quot;, &quot;)</span><br><span class="line">);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>Actions</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const doTask = action(() =&gt; &#123;</span><br><span class="line">todos.find(todo =&gt; !todo.completed).completed = true</span><br><span class="line">&#125;);</span><br><span class="line">doTask()</span><br></pre></td></tr></table></figure>

<h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p><strong>什么是装饰器 Decorators</strong></p>
<ul>
<li>核⼼思想：保留原来的名字和主功能，添加⼀<br>些附庸功能</li>
<li>⼀种设计模式，⽤来“装饰”⼀个函数或对象</li>
<li>ES7 新语法，⽤来装饰类或者属性</li>
</ul>
<p>@observable 可以在实例字段和属性 getter 上使用。 对于对象的哪部分需要成为可观察的，@observable 提供了细粒度的控制。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; observable, computed &#125; from &quot;mobx&quot;;</span><br><span class="line"></span><br><span class="line">class OrderLine &#123;</span><br><span class="line">    @observable price = 0;</span><br><span class="line">    @observable amount = 1;</span><br><span class="line"></span><br><span class="line">    @computed get total() &#123;</span><br><span class="line">        return this.price * this.amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mobx-的装饰器写法"><a href="#mobx-的装饰器写法" class="headerlink" title="mobx 的装饰器写法"></a>mobx 的装饰器写法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; observable, autorun, computed, action &#125; from &#x27;mobx&#x27;;</span><br><span class="line">class Todo &#123;</span><br><span class="line"> @observable todos = []</span><br><span class="line"> constructor() &#123;</span><br><span class="line"> autorun(() =&gt; &#123;</span><br><span class="line"> console.log(</span><br><span class="line"> `剩余任务:$&#123;this.uncompletedCount&#125;`,</span><br><span class="line"> this.todos</span><br><span class="line"> .filter(todo =&gt; !todo.completed)</span><br><span class="line"> .map(todo =&gt; todo.title)</span><br><span class="line"> .join(&quot;, &quot;)</span><br><span class="line"> );</span><br><span class="line"> &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"> @computed get uncompletedCount() &#123;</span><br><span class="line"> return this.todos.filter(todo =&gt; !todo.completed).length;</span><br><span class="line"> &#125;</span><br><span class="line"> @action addTodo(title) &#123;</span><br><span class="line"> this.todos.push(&#123;</span><br><span class="line"> title: title,</span><br><span class="line"> completed: false</span><br><span class="line"> &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"> @action doTask()&#123;</span><br><span class="line"> this.todos.find(todo =&gt; !todo.completed).completed = true</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>状态的改变引发⼀系列⾃动⾏为</p>
<h3 id="React-项⽬中使⽤装饰器"><a href="#React-项⽬中使⽤装饰器" class="headerlink" title="React 项⽬中使⽤装饰器"></a>React 项⽬中使⽤装饰器</h3><ul>
<li>yarn eject</li>
<li>yarn add @babel/plugin-proposal-decorators</li>
<li>修改 package.json， 找到 babel 字段， 添加<code>&quot;plugins&quot;: [ &quot;@babel/plugin-proposal-decorators&quot; ]</code></li>
</ul>
<h2 id="3-mobx-react"><a href="#3-mobx-react" class="headerlink" title="3.mobx-react"></a>3.mobx-react</h2><h3 id="在-Class-组件使⽤-mobx"><a href="#在-Class-组件使⽤-mobx" class="headerlink" title="在 Class 组件使⽤ mobx"></a>在 Class 组件使⽤ mobx</h3><ul>
<li>设置 Store</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; observable, action &#125; from &#x27;mobx&#x27;;</span><br><span class="line">class AboutStore &#123;</span><br><span class="line"> @observable counter = 1;</span><br><span class="line"> @action add() &#123;</span><br><span class="line"> this.counter++;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default new AboutStore;</span><br></pre></td></tr></table></figure>

<ul>
<li>提供数据源</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; Provider &#125; from &#x27;mobx-react&#x27;;</span><br><span class="line">ReactDOM.render(</span><br><span class="line"> &lt;React.StrictMode&gt;</span><br><span class="line"> &lt;Router&gt;</span><br><span class="line"> &lt;Provider homeStore=&#123;homeStore&#125; aboutStore=&#123;aboutStore&#125;&gt;</span><br><span class="line"> &lt;App /&gt;</span><br><span class="line"> &lt;/Provider&gt;</span><br><span class="line"></span><br><span class="line"> &lt;/Router&gt;</span><br><span class="line"> &lt;/React.StrictMode&gt;,</span><br><span class="line"> document.getElementById(&#x27;root&#x27;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>使用数据源</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; observer, inject &#125; from &#x27;mobx-react&#x27;;</span><br><span class="line">@inject(&#x27;aboutStore&#x27;)</span><br><span class="line">@inject(&#x27;homeStore&#x27;)</span><br><span class="line">@observer</span><br><span class="line">class About extends Component &#123;</span><br><span class="line"> render() &#123;</span><br><span class="line"> return (</span><br><span class="line"> &lt;div&gt;</span><br><span class="line"> &lt;h1&gt;About&lt;/h1&gt;</span><br><span class="line"> &lt;p&gt;current counter : &#123;this.props.aboutStore.counter&#125;&lt;/p&gt;</span><br><span class="line"> &lt;p&gt;home counter: &#123;this.props.homeStore.counter&#125;&lt;/p&gt;</span><br><span class="line"> &lt;Link to=&quot;/&quot;&gt;去⾸⻚&lt;/Link&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"> );</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="在函数组件使⽤-mobx"><a href="#在函数组件使⽤-mobx" class="headerlink" title="在函数组件使⽤ mobx"></a>在函数组件使⽤ mobx</h3><ul>
<li>设置 Store</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; observable, action, computed &#125; from &#x27;mobx&#x27;;</span><br><span class="line">export class HomeStore &#123;</span><br><span class="line"> @observable counter = 1;</span><br><span class="line"> @computed get doubleCounter() &#123;</span><br><span class="line"> return this.counter * 2;</span><br><span class="line"> &#125;</span><br><span class="line"> @action add() &#123;</span><br><span class="line"> this.counter++;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建 Context 对象</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import &#123; HomeStore &#125; from &#x27;../stores/home&#x27;;</span><br><span class="line">import &#123; AboutStore &#125; from &#x27;../stores/about&#x27;;</span><br><span class="line">export const storesContext = React.createContext(&#123;</span><br><span class="line"> homeStore: new HomeStore(),</span><br><span class="line"> aboutStore: new AboutStore()</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>useContext</li>
</ul>
<p>设置 useStores 函数，⽤于在函数组件<br>内获取 context 对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import &#123; storesContext &#125; from &#x27;../contexts&#x27;;</span><br><span class="line">export const useStores = () =&gt; React.useContext(storesContext);</span><br></pre></td></tr></table></figure>

<ul>
<li>使⽤ context</li>
</ul>
<p>观察组件，通过 useStore 获取 context<br>对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &#x27;react&#x27;;</span><br><span class="line">import &#123; observer &#125; from &#x27;mobx-react&#x27;;</span><br><span class="line">import &#123; useStores &#125; from &#x27;../hooks/use-stores&#x27;;</span><br><span class="line">const About = observer(() =&gt; &#123;</span><br><span class="line"> const &#123; homeStore, aboutStore &#125; = useStores();</span><br><span class="line"> return (</span><br><span class="line"> &lt;div&gt;</span><br><span class="line"> &lt;h1&gt;About&lt;/h1&gt;</span><br><span class="line"> &lt;p&gt;current counter : &#123;aboutStore.counter&#125;&lt;/p&gt;</span><br><span class="line"> &lt;p&gt;home counter: &#123;homeStore.counter&#125;&lt;/p&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"> )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>参考</strong></p>
<ul>
<li><a href="https://cn.mobx.js.org/">mobx 中文文档</a></li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo nexT 7.8.0 添加背景图片</title>
    <url>/posts/b56cb502/</url>
    <content><![CDATA[<p>版本信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;hexo&quot;: &quot;^5.0.0&quot;,</span><br><span class="line">&quot;NexT&quot;: &quot;7.8.0&quot;,</span><br></pre></td></tr></table></figure>

<p><strong>由于 next 版本较新，next 主题更新至 7.0+版本后取消了_custom 文件夹以及 custom.styl 文件。</strong></p>
<p>在这里提醒下<strong>不要打开</strong>themes/next/_config.yml 配置文件搜索 custom 以下代码里的 style 的 注释（博主踩过坑）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  #head: source/_data/head.swig</span><br><span class="line">  #header: source/_data/header.swig</span><br><span class="line">  #sidebar: source/_data/sidebar.swig</span><br><span class="line">  #postMeta: source/_data/post-meta.swig</span><br><span class="line">  #postBodyEnd: source/_data/post-body-end.swig</span><br><span class="line">  #footer: source/_data/footer.swig</span><br><span class="line">  #bodyEnd: source/_data/body-end.swig</span><br><span class="line">  #variable: source/_data/variables.styl</span><br><span class="line">  #mixin: source/_data/mixins.styl</span><br><span class="line">  # style: source/_data/styles.styl</span><br></pre></td></tr></table></figure>

<p>首先在 themes/next/souces/images 添加你喜欢的背景图片，这里我推荐在知乎里面找推荐。</p>
<p>然后在 themes/next/souces 下新建_data 文件，创建 styles.styl,添加内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    background:url(/images/background.jpg); // 可以是路径也可以是链接</span><br><span class="line">    background-repeat: no-repeat; // 不重复</span><br><span class="line">    background-attachment:fixed; // 固定住背景图片</span><br><span class="line">    background-position:50% 50%; // 图片位置：居中</span><br><span class="line">    background-size: 100% 100%; // 图片长宽扩充为100%</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后需要在 yourblog/themes/next/source/css 下找到 main.styl 文件，并在最后一行添上如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@import &quot;../_data/styles.styl&quot;;</span><br></pre></td></tr></table></figure>

<p>最后的最后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p>就可以看到最终效果了！！！！</p>
]]></content>
      <categories>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>如何理解Vue的.sync修饰符以及v-model</title>
    <url>/posts/1c175475/</url>
    <content><![CDATA[<h3 id="sync"><a href="#sync" class="headerlink" title=".sync"></a>.sync</h3><p>vue 修饰符 sync 的功能是：当一个子组件改变了一个 props 的值时，这个变化也会同步到父组件中所绑定。</p>
<p>这个功能是怎么实现的呢？</p>
<p>Vue 组件不能修改 props 外部数据，但是$emit可以触发事件，并传参，$event 可获取$emit 的参数。</p>
<p>我们看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Child.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;child&quot;&gt;</span><br><span class="line">   子组件：&#123;&#123;money&#125;&#125;</span><br><span class="line">//触发update:money事件，并传参</span><br><span class="line">   &lt;button @click=&quot;$emit(&#x27;update:money&#x27;,money-100)&quot;&gt;&lt;span&gt;花钱&lt;/span&gt;&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line"></span><br><span class="line">props:[&quot;money&quot;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">#child&#123;</span><br><span class="line">  border :1px solid red;</span><br><span class="line">  padding:2px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后$event 获取传的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//App.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">   父组件： 我现在有&#123;&#123;total&#125;&#125;</span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">//$event 获取传的参数赋值给total</span><br><span class="line">    &lt;Child :money=&quot;total&quot; v-on:update:money=&quot;total=$event&quot;/&gt;</span><br><span class="line"></span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Child from&quot;./Child.vue&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">total:10000</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123; Child:Child&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">#app&#123;</span><br><span class="line">  border :2px solid blue;</span><br><span class="line">  padding:2px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为这种场景很常见，所以尤雨溪发明了.sync 修饰符，上面的代码<strong>:money=”total” v-on:update:money=”total=$event”可以简化为:money.sync=”total”</strong></p>
<p>下面是运行动画：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/12/17207b0ebb162b47~tplv-t2oaga2asx-watermark.awebp"></p>
<p><a href="https://codesandbox.io/s/eloquent-wave-bc7bb">代码点击</a></p>
<h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><p>v-model 也是个语法糖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v-model=&quot;x&quot;等价于 ：value=&quot;x&quot;,@input=&quot;x=$event.target.value&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当 v-model 用于普通 input 上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;&#123;message&#125;&#125;</span><br><span class="line">    &lt;hr/&gt;</span><br><span class="line">    &lt;input v-model=&quot;message&quot; placeholder=&quot;你好&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;App&quot;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &quot;&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot;&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>动画演示：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/3/17277f6ca1d24f4d~tplv-t2oaga2asx-watermark.awebp"></p>
<p>当 v-model 用于组件上</p>
<p>父组件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &#123;&#123;price&#125;&#125;</span><br><span class="line">        &lt;hr/&gt;</span><br><span class="line">        &lt;test v-model=&quot;price&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import test from &#x27;./components/Test.vue&#x27;;</span><br><span class="line">    export default &#123;</span><br><span class="line">        components:&#123;test&#125;,</span><br><span class="line">        name: &quot;App&quot;,</span><br><span class="line">        data()&#123;</span><br><span class="line">            return&#123;</span><br><span class="line">                price:100</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot;&gt;</span><br><span class="line">&lt;/style&gt;子组件</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>子组件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;label&gt;</span><br><span class="line">      &lt;input ref=&quot;input&quot; :value=&quot;value&quot;</span><br><span class="line">      @input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;//子组件触发事件，把输入的参数传给price</span><br><span class="line">      &gt;</span><br><span class="line">    &lt;/label&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;App&quot;,</span><br><span class="line">  props: [&quot;value&quot;],//子组件把value传给父组件，父组件绑定value=&quot;price&quot;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot;&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由上面代码我们可以看出子组件把 value 传给父组件，因为<strong> v-model=”price”等价于 ：value=”price”,@input=”price=$event.target.value”,</strong>父组件动态绑定了 value，然后 input 事件那输入的 value 参数传给了 price,所以我们就能看到以下效果：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/3/1727846768ecc1e0~tplv-t2oaga2asx-watermark.awebp"></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
</search>
