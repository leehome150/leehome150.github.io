<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>手把手教你写EventHub（发布-订阅）</title>
    <url>/posts/ee1ff54b/</url>
    <content><![CDATA[<blockquote>
<p>手写 EventBus 作为经典的前端手写面试题，在工作之余我觉得还是得记录一下 😊</p>
</blockquote>
<p><strong>什么是 EventHub</strong></p>
<p>EventHub 是基于<strong>发布订阅模式</strong>实现的一个实例, 翻译为事件中心,常用于多模块(组件)间的通信。</p>
<p>今天我们就简单的实现 EventHub 的<code>发布、订阅和取消订阅</code>：<br>首先我们确定<code>Api</code>:</p>
<ul>
<li>on 订阅（监听）</li>
<li>emit 发布（触发）</li>
<li>off 取消订阅</li>
</ul>
<p><strong>实现发布和订阅</strong></p>
<p>我们得用一个变量<strong>eventMap</strong>来暂存事件名字（key）和事件(value)，这里我们用一个数组来记录事件（因为考虑多次订阅）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventHub</span> </span>&#123;</span><br><span class="line">  private eventMap: &#123; [key: string]: <span class="built_in">Array</span>&lt;<span class="function">(<span class="params">params?</span>) =&gt;</span> <span class="keyword">void</span>&gt; &#125; = &#123;&#125;;</span><br><span class="line">  <span class="function"><span class="title">on</span>(<span class="params">eventName, fn</span>)</span> &#123;&#125;</span><br><span class="line">  <span class="function"><span class="title">emit</span>(<span class="params">eventName</span>)</span> &#123;&#125;</span><br><span class="line">  <span class="function"><span class="title">off</span>(<span class="params">eventName</span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> EventHub;</span><br></pre></td></tr></table></figure>

<p>当我们订阅一个事件的时候，我们把这个事件 push 到订阅的东西的事件队列中，比如我在手机闹钟里面订了个 3 秒后的闹钟:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> EventHub <span class="keyword">from</span> <span class="string">&quot;../src/index&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> eventHub = <span class="keyword">new</span> EventHub();</span><br><span class="line"></span><br><span class="line">eventHub.on(<span class="string">&quot;闹钟&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;闹钟响了&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">eventHub.emit(<span class="string">&quot;闹钟&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>然后我们在类里面的<code>on</code>函数把事件 push 进去：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventHub</span> </span>&#123;</span><br><span class="line">  private eventMap: &#123; [key: string]: <span class="built_in">Array</span>&lt;<span class="function">(<span class="params">params?：any</span>) =&gt;</span> <span class="keyword">void</span>&gt; &#125; = &#123;&#125;;</span><br><span class="line">  <span class="function"><span class="title">on</span>(<span class="params">eventName: string, fn: (params?: any) =&gt; <span class="keyword">void</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.eventMap[eventName] = <span class="built_in">this</span>.eventMap[eventName] || [];</span><br><span class="line">    <span class="built_in">this</span>.eventMap[eventName].push(fn);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">emit</span>(<span class="params">eventName</span>)</span> &#123;&#125;</span><br><span class="line">  <span class="function"><span class="title">off</span>(<span class="params">eventName</span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> EventHub;</span><br></pre></td></tr></table></figure>

<p>我们在<code>emit</code>触发执行逻辑：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventHub</span> </span>&#123;</span><br><span class="line">  private eventMap: &#123; [key: string]: <span class="built_in">Array</span>&lt;<span class="function">(<span class="params">params?: any</span>) =&gt;</span> <span class="keyword">void</span>&gt; &#125; = &#123;&#125;;</span><br><span class="line">  <span class="function"><span class="title">on</span>(<span class="params">eventName: string, fn: (params?: any) =&gt; <span class="keyword">void</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.eventMap[eventName] = <span class="built_in">this</span>.eventMap[eventName] || [];</span><br><span class="line">    <span class="built_in">this</span>.eventMap[eventName].push(fn);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">emit</span>(<span class="params">eventName: string</span>)</span> &#123;</span><br><span class="line">    (<span class="built_in">this</span>.eventMap[eventName] || []).forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> fn());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">off</span>(<span class="params">eventName: string</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(eventName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> EventHub;</span><br></pre></td></tr></table></figure>

<p>执行触发的代码，看控制台（提示：node 运行 ts 文件请下载 ts-node）</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7adeff31547c4b26b739a077107dd40e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br><strong>实现取消订阅：</strong><br>当我们在 emit 之前 off 闹钟的订阅</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> EventHub <span class="keyword">from</span> <span class="string">&quot;../src/index&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> eventHub = <span class="keyword">new</span> EventHub();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;闹钟响了&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;;</span><br><span class="line">eventHub.on(<span class="string">&quot;闹钟&quot;</span>, fn);</span><br><span class="line">eventHub.off(<span class="string">&quot;闹钟&quot;</span>, fn);</span><br><span class="line">eventHub.emit(<span class="string">&quot;闹钟&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>加上取消订阅的逻辑：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">off</span>(<span class="params">eventName: string, fn: (params?: any) =&gt; <span class="keyword">void</span></span>)</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> index = <span class="built_in">this</span>.eventMap[eventName].findIndex(<span class="function">(<span class="params">item</span>) =&gt;</span> item === fn);</span><br><span class="line">   <span class="keyword">if</span> (index === -<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">   <span class="built_in">this</span>.eventMap[eventName].splice(index, <span class="number">1</span>);</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&quot;取消闹钟成功&quot;</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>执行取消成功：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cece88b0c35949d7b82db8fca752b106~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br><a href="https://github.com/leehome150/EventHub">源代码点击</a></p>
]]></content>
      <categories>
        <category>手写系列</category>
      </categories>
      <tags>
        <tag>eventHub</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo nexT 7.8.0 添加背景图片</title>
    <url>/posts/b56cb502/</url>
    <content><![CDATA[<p>版本信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;hexo&quot;: &quot;^5.0.0&quot;,</span><br><span class="line">&quot;NexT&quot;: &quot;7.8.0&quot;,</span><br></pre></td></tr></table></figure>

<p><strong>由于 next 版本较新，next 主题更新至 7.0+版本后取消了_custom 文件夹以及 custom.styl 文件。</strong></p>
<p>在这里提醒下<strong>不要打开</strong>themes/next/_config.yml 配置文件搜索 custom 以下代码里的 style 的 注释（博主踩过坑）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  #head: source/_data/head.swig</span><br><span class="line">  #header: source/_data/header.swig</span><br><span class="line">  #sidebar: source/_data/sidebar.swig</span><br><span class="line">  #postMeta: source/_data/post-meta.swig</span><br><span class="line">  #postBodyEnd: source/_data/post-body-end.swig</span><br><span class="line">  #footer: source/_data/footer.swig</span><br><span class="line">  #bodyEnd: source/_data/body-end.swig</span><br><span class="line">  #variable: source/_data/variables.styl</span><br><span class="line">  #mixin: source/_data/mixins.styl</span><br><span class="line">  # style: source/_data/styles.styl</span><br></pre></td></tr></table></figure>

<p>首先在 themes/next/souces/images 添加你喜欢的背景图片，这里我推荐在知乎里面找推荐。</p>
<p>然后在 themes/next/souces 下新建_data 文件，创建 styles.styl,添加内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    background:url(/images/background.jpg); // 可以是路径也可以是链接</span><br><span class="line">    background-repeat: no-repeat; // 不重复</span><br><span class="line">    background-attachment:fixed; // 固定住背景图片</span><br><span class="line">    background-position:50% 50%; // 图片位置：居中</span><br><span class="line">    background-size: 100% 100%; // 图片长宽扩充为100%</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后需要在 yourblog/themes/next/source/css 下找到 main.styl 文件，并在最后一行添上如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@import &quot;../_data/styles.styl&quot;;</span><br></pre></td></tr></table></figure>

<p>最后的最后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p>就可以看到最终效果了！！！！</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Next.js 的三种渲染方式</title>
    <url>/posts/b2ae764/</url>
    <content><![CDATA[<blockquote>
<p>客户端渲染(BSR)<br>静态页面生成(SSG)<br>服务端渲染(SSR)</p>
</blockquote>
<ul>
<li><h4 id="客户端渲染-BSR"><a href="#客户端渲染-BSR" class="headerlink" title="客户端渲染(BSR)"></a>客户端渲染(BSR)</h4></li>
</ul>
<p>顾名思义，客户端渲染只是在浏览器执行的渲染，我们一半用 JS、React、Vue 创建 HTML,举个例子：我们渲染一个列表:<br>我们先通过 usePost 这个自定义 Hook 通过 axios 返回一个的文件列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const usePosts = () =&gt; &#123;</span><br><span class="line">  const [posts, set_posts] = useState&lt;Acticle[]&gt;();</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    axios.get(&quot;/api/v1/posts&quot;).then((res) =&gt; &#123;</span><br><span class="line">      set_posts(res.data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, []);</span><br><span class="line">  return &#123; posts &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们然后把他渲染在页面上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const posts = () =&gt; &#123;</span><br><span class="line">  const &#123; posts &#125; = usePosts();</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;文章列表&lt;/h1&gt;</span><br><span class="line">      &#123;posts?.map((item) =&gt; &#123;</span><br><span class="line">        return &lt;div key=&#123;item.id&#125;&gt;&#123;item.title&#125;&lt;/div&gt;;</span><br><span class="line">      &#125;)&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由上面我们可以知道客户端渲染通过<strong> AJAX</strong> 得到成功响应，然后渲染动态内容（静态内容与服务器渲染，比如：文章列表这几个字）。这也是我们现如今比较常用的渲染方式，因为大部分公司都是前后端分离。</p>
<p>他的缺点也很明显：</p>
<ul>
<li>白屏<br>但是我们在 set_posts(res.data)之前打个 debugger,发现页面看不到文章了。</li>
<li>SEO 不友好<br>我们打开源代码会发现看不到渲染的数据，只看到引用的 JS,因为搜索引擎不会执行 JS,只能看到 HTML。</li>
</ul>
<p>这也有了下面两种渲染方式的用武之地：</p>
<ul>
<li><h4 id="静态文件生成-SSG"><a href="#静态文件生成-SSG" class="headerlink" title="静态文件生成(SSG)"></a>静态文件生成(SSG)</h4></li>
</ul>
<p>背景：如果返回的文件与用户无关，都是一样的，那为什么不一次生成，然后发给每个人，N 次客户端渲染就变成了一次静态页面生成，这个就叫做动态内容静态化。</p>
<p>Next.js 提供 getStaticProps 这个 API,就可以直接通过 Props 传入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const posts: NextPage&lt;Props&gt; = (props) =&gt; &#123;</span><br><span class="line">  const &#123; posts &#125; = props;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;content&quot;&gt;</span><br><span class="line">      &lt;h1&gt;文章列表&lt;/h1&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;posts?.map((item) =&gt; &#123;</span><br><span class="line">          return (</span><br><span class="line">            &lt;Link href=&#123;`/posts/$&#123;item.title&#125;`&#125; key=&#123;item.title&#125;&gt;</span><br><span class="line">              &lt;a&gt;</span><br><span class="line">                &lt;li key=&#123;item.title&#125;&gt;</span><br><span class="line">                  &#123;item.id&#125;.&#123;item.title&#125;</span><br><span class="line">                &lt;/li&gt;</span><br><span class="line">              &lt;/a&gt;</span><br><span class="line">            &lt;/Link&gt;</span><br><span class="line">          );</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default posts;</span><br><span class="line"></span><br><span class="line">export const getStaticProps = async () =&gt; &#123;</span><br><span class="line">  const posts = await getPosts();</span><br><span class="line">  return &#123;</span><br><span class="line">    props: &#123; posts: JSON.parse(JSON.stringify(posts)) &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样的好处：我们不用 AJAX 也能拿到内容，不会白屏，而且我们查看源代码也能看到数据内容，也有利于 SEO。</p>
<ul>
<li><h4 id="服务端渲染（SSR）"><a href="#服务端渲染（SSR）" class="headerlink" title="服务端渲染（SSR）"></a>服务端渲染（SSR）</h4>如果动态内容与用户先关联，较难提前静态化，这个时候我们可以使用服务端渲染。<br>Next.js 提供 getStaticProps 这个 API,就可以直接通过 Props 传入,比如我们获取用户的浏览器类型：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const Index: NextPage&lt;Props&gt; = (props) =&gt; &#123;</span><br><span class="line">const &#123; browser &#125; = props;</span><br><span class="line">return (</span><br><span class="line">  &lt;div className=&#123;styles.container&#125;&gt;</span><br><span class="line">    &lt;h1&gt;</span><br><span class="line">      你的浏览器是&#123;browser.name&#125;,版本为&#123;browser.version&#125;</span><br><span class="line">    &lt;/h1&gt;</span><br><span class="line">    &lt;img src=&#123;img&#125; alt=&quot;&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br><span class="line">&#125;;</span><br><span class="line">export default Index;</span><br><span class="line">export const getServerSideProps: GetServerSideProps = async (context) =&gt; &#123;</span><br><span class="line">const ua = context.req.headers[&quot;user-agent&quot;];</span><br><span class="line">const result = new UAParser(ua).getResult();</span><br><span class="line">return &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    browser: result.browser,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
服务端渲染的好处也是不会白屏，有利于 SEO 优化，相比于 SSG 能实现服务端渲染跟用户相关的动态内容。</li>
</ul>
]]></content>
      <categories>
        <category>Next.js</category>
      </categories>
      <tags>
        <tag>Next.js</tag>
      </tags>
  </entry>
  <entry>
    <title>如何理解Vue的.sync修饰符以及v-model</title>
    <url>/posts/1c175475/</url>
    <content><![CDATA[<h3 id="sync"><a href="#sync" class="headerlink" title=".sync"></a>.sync</h3><p>vue 修饰符 sync 的功能是：当一个子组件改变了一个 props 的值时，这个变化也会同步到父组件中所绑定。</p>
<p>这个功能是怎么实现的呢？</p>
<p>Vue 组件不能修改 props 外部数据，但是$emit可以触发事件，并传参，$event 可获取$emit 的参数。</p>
<p>我们看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Child.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;child&quot;&gt;</span><br><span class="line">   子组件：&#123;&#123;money&#125;&#125;</span><br><span class="line">//触发update:money事件，并传参</span><br><span class="line">   &lt;button @click=&quot;$emit(&#x27;update:money&#x27;,money-100)&quot;&gt;&lt;span&gt;花钱&lt;/span&gt;&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line"></span><br><span class="line">props:[&quot;money&quot;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">#child&#123;</span><br><span class="line">  border :1px solid red;</span><br><span class="line">  padding:2px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后$event 获取传的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//App.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">   父组件： 我现在有&#123;&#123;total&#125;&#125;</span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">//$event 获取传的参数赋值给total</span><br><span class="line">    &lt;Child :money=&quot;total&quot; v-on:update:money=&quot;total=$event&quot;/&gt;</span><br><span class="line"></span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Child from&quot;./Child.vue&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">total:10000</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123; Child:Child&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">#app&#123;</span><br><span class="line">  border :2px solid blue;</span><br><span class="line">  padding:2px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为这种场景很常见，所以尤雨溪发明了.sync 修饰符，上面的代码<strong>:money=”total” v-on:update:money=”total=$event”可以简化为:money.sync=”total”</strong></p>
<p>下面是运行动画：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/12/17207b0ebb162b47~tplv-t2oaga2asx-watermark.awebp"></p>
<p><a href="https://codesandbox.io/s/eloquent-wave-bc7bb">代码点击</a></p>
<h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><p>v-model 也是个语法糖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v-model=&quot;x&quot;等价于 ：value=&quot;x&quot;,@input=&quot;x=$event.target.value&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当 v-model 用于普通 input 上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;&#123;message&#125;&#125;</span><br><span class="line">    &lt;hr/&gt;</span><br><span class="line">    &lt;input v-model=&quot;message&quot; placeholder=&quot;你好&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;App&quot;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &quot;&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot;&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>动画演示：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/3/17277f6ca1d24f4d~tplv-t2oaga2asx-watermark.awebp"></p>
<p>当 v-model 用于组件上</p>
<p>父组件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &#123;&#123;price&#125;&#125;</span><br><span class="line">        &lt;hr/&gt;</span><br><span class="line">        &lt;test v-model=&quot;price&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import test from &#x27;./components/Test.vue&#x27;;</span><br><span class="line">    export default &#123;</span><br><span class="line">        components:&#123;test&#125;,</span><br><span class="line">        name: &quot;App&quot;,</span><br><span class="line">        data()&#123;</span><br><span class="line">            return&#123;</span><br><span class="line">                price:100</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot;&gt;</span><br><span class="line">&lt;/style&gt;子组件</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>子组件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;label&gt;</span><br><span class="line">      &lt;input ref=&quot;input&quot; :value=&quot;value&quot;</span><br><span class="line">      @input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;//子组件触发事件，把输入的参数传给price</span><br><span class="line">      &gt;</span><br><span class="line">    &lt;/label&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;App&quot;,</span><br><span class="line">  props: [&quot;value&quot;],//子组件把value传给父组件，父组件绑定value=&quot;price&quot;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot;&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由上面代码我们可以看出子组件把 value 传给父组件，因为<strong> v-model=”price”等价于 ：value=”price”,@input=”price=$event.target.value”,</strong>父组件动态绑定了 value，然后 input 事件那输入的 value 参数传给了 price,所以我们就能看到以下效果：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/3/1727846768ecc1e0~tplv-t2oaga2asx-watermark.awebp"></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>mobx 和 mobx-react 入门</title>
    <url>/posts/e13966ac/</url>
    <content><![CDATA[<h2 id="1-为什么需要状态管理？"><a href="#1-为什么需要状态管理？" class="headerlink" title="1.为什么需要状态管理？"></a>1.为什么需要状态管理？</h2><h3 id="组件内"><a href="#组件内" class="headerlink" title="组件内"></a>组件内</h3><ul>
<li>class 组件 state</li>
<li>函数组件 useState</li>
</ul>
<h3 id="组件间"><a href="#组件间" class="headerlink" title="组件间"></a>组件间</h3><ul>
<li>父子之间通信用 props 传递</li>
<li>爷孙之间通信传递两次 props</li>
<li>但是任意组件？</li>
</ul>
<p>这个时候我们就需要用到 mobx 和 mobx-react（这里不讲 redux）</p>
<h2 id="2-mobx"><a href="#2-mobx" class="headerlink" title="2.mobx"></a>2.mobx</h2><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/7/173270ed17dabb91~tplv-t2oaga2asx-image.image"></p>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p><a href="https://cn.mobx.js.org/">mobx 中文文档</a></p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ul>
<li>State</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; observable, computed, action, autorun &#125; from &quot;mobx&quot;;</span><br><span class="line">//State，被观察者</span><br><span class="line">const todos = (observable([</span><br><span class="line"> &#123;</span><br><span class="line"> title: &quot;起床&quot;,</span><br><span class="line"> completed: false</span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line"> title: &quot;穿⾐&quot;,</span><br><span class="line"> completed: false</span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line"> title: &quot;洗漱&quot;,</span><br><span class="line"> completed: false</span><br><span class="line"> &#125;</span><br><span class="line">]));</span><br></pre></td></tr></table></figure>

<ul>
<li>Computed</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Computed values ,由 State 的更新触发</span><br><span class="line">let uncompletedCount = computed(</span><br><span class="line">() =&gt; todos.filter(todo =&gt; !todo.completed).length</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>Reactions</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Reactions， 由 State 和 Computed Values 的改变触发执⾏</span><br><span class="line">autorun(() =&gt; &#123;</span><br><span class="line">console.log(</span><br><span class="line">`剩余任务:$&#123;uncompletedCount&#125;`,</span><br><span class="line">todos</span><br><span class="line">.filter(todo =&gt; !todo.completed)</span><br><span class="line">.map(todo =&gt; todo.title)</span><br><span class="line">.join(&quot;, &quot;)</span><br><span class="line">);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>Actions</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const doTask = action(() =&gt; &#123;</span><br><span class="line">todos.find(todo =&gt; !todo.completed).completed = true</span><br><span class="line">&#125;);</span><br><span class="line">doTask()</span><br></pre></td></tr></table></figure>

<h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p><strong>什么是装饰器 Decorators</strong></p>
<ul>
<li>核⼼思想：保留原来的名字和主功能，添加⼀<br>些附庸功能</li>
<li>⼀种设计模式，⽤来“装饰”⼀个函数或对象</li>
<li>ES7 新语法，⽤来装饰类或者属性</li>
</ul>
<p>@observable 可以在实例字段和属性 getter 上使用。 对于对象的哪部分需要成为可观察的，@observable 提供了细粒度的控制。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; observable, computed &#125; from &quot;mobx&quot;;</span><br><span class="line"></span><br><span class="line">class OrderLine &#123;</span><br><span class="line">    @observable price = 0;</span><br><span class="line">    @observable amount = 1;</span><br><span class="line"></span><br><span class="line">    @computed get total() &#123;</span><br><span class="line">        return this.price * this.amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mobx-的装饰器写法"><a href="#mobx-的装饰器写法" class="headerlink" title="mobx 的装饰器写法"></a>mobx 的装饰器写法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; observable, autorun, computed, action &#125; from &#x27;mobx&#x27;;</span><br><span class="line">class Todo &#123;</span><br><span class="line"> @observable todos = []</span><br><span class="line"> constructor() &#123;</span><br><span class="line"> autorun(() =&gt; &#123;</span><br><span class="line"> console.log(</span><br><span class="line"> `剩余任务:$&#123;this.uncompletedCount&#125;`,</span><br><span class="line"> this.todos</span><br><span class="line"> .filter(todo =&gt; !todo.completed)</span><br><span class="line"> .map(todo =&gt; todo.title)</span><br><span class="line"> .join(&quot;, &quot;)</span><br><span class="line"> );</span><br><span class="line"> &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"> @computed get uncompletedCount() &#123;</span><br><span class="line"> return this.todos.filter(todo =&gt; !todo.completed).length;</span><br><span class="line"> &#125;</span><br><span class="line"> @action addTodo(title) &#123;</span><br><span class="line"> this.todos.push(&#123;</span><br><span class="line"> title: title,</span><br><span class="line"> completed: false</span><br><span class="line"> &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"> @action doTask()&#123;</span><br><span class="line"> this.todos.find(todo =&gt; !todo.completed).completed = true</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>状态的改变引发⼀系列⾃动⾏为</p>
<h3 id="React-项⽬中使⽤装饰器"><a href="#React-项⽬中使⽤装饰器" class="headerlink" title="React 项⽬中使⽤装饰器"></a>React 项⽬中使⽤装饰器</h3><ul>
<li>yarn eject</li>
<li>yarn add @babel/plugin-proposal-decorators</li>
<li>修改 package.json， 找到 babel 字段， 添加<code>&quot;plugins&quot;: [ &quot;@babel/plugin-proposal-decorators&quot; ]</code></li>
</ul>
<h2 id="3-mobx-react"><a href="#3-mobx-react" class="headerlink" title="3.mobx-react"></a>3.mobx-react</h2><h3 id="在-Class-组件使⽤-mobx"><a href="#在-Class-组件使⽤-mobx" class="headerlink" title="在 Class 组件使⽤ mobx"></a>在 Class 组件使⽤ mobx</h3><ul>
<li>设置 Store</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; observable, action &#125; from &#x27;mobx&#x27;;</span><br><span class="line">class AboutStore &#123;</span><br><span class="line"> @observable counter = 1;</span><br><span class="line"> @action add() &#123;</span><br><span class="line"> this.counter++;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default new AboutStore;</span><br></pre></td></tr></table></figure>

<ul>
<li>提供数据源</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; Provider &#125; from &#x27;mobx-react&#x27;;</span><br><span class="line">ReactDOM.render(</span><br><span class="line"> &lt;React.StrictMode&gt;</span><br><span class="line"> &lt;Router&gt;</span><br><span class="line"> &lt;Provider homeStore=&#123;homeStore&#125; aboutStore=&#123;aboutStore&#125;&gt;</span><br><span class="line"> &lt;App /&gt;</span><br><span class="line"> &lt;/Provider&gt;</span><br><span class="line"></span><br><span class="line"> &lt;/Router&gt;</span><br><span class="line"> &lt;/React.StrictMode&gt;,</span><br><span class="line"> document.getElementById(&#x27;root&#x27;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>使用数据源</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; observer, inject &#125; from &#x27;mobx-react&#x27;;</span><br><span class="line">@inject(&#x27;aboutStore&#x27;)</span><br><span class="line">@inject(&#x27;homeStore&#x27;)</span><br><span class="line">@observer</span><br><span class="line">class About extends Component &#123;</span><br><span class="line"> render() &#123;</span><br><span class="line"> return (</span><br><span class="line"> &lt;div&gt;</span><br><span class="line"> &lt;h1&gt;About&lt;/h1&gt;</span><br><span class="line"> &lt;p&gt;current counter : &#123;this.props.aboutStore.counter&#125;&lt;/p&gt;</span><br><span class="line"> &lt;p&gt;home counter: &#123;this.props.homeStore.counter&#125;&lt;/p&gt;</span><br><span class="line"> &lt;Link to=&quot;/&quot;&gt;去⾸⻚&lt;/Link&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"> );</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="在函数组件使⽤-mobx"><a href="#在函数组件使⽤-mobx" class="headerlink" title="在函数组件使⽤ mobx"></a>在函数组件使⽤ mobx</h3><ul>
<li>设置 Store</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; observable, action, computed &#125; from &#x27;mobx&#x27;;</span><br><span class="line">export class HomeStore &#123;</span><br><span class="line"> @observable counter = 1;</span><br><span class="line"> @computed get doubleCounter() &#123;</span><br><span class="line"> return this.counter * 2;</span><br><span class="line"> &#125;</span><br><span class="line"> @action add() &#123;</span><br><span class="line"> this.counter++;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建 Context 对象</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import &#123; HomeStore &#125; from &#x27;../stores/home&#x27;;</span><br><span class="line">import &#123; AboutStore &#125; from &#x27;../stores/about&#x27;;</span><br><span class="line">export const storesContext = React.createContext(&#123;</span><br><span class="line"> homeStore: new HomeStore(),</span><br><span class="line"> aboutStore: new AboutStore()</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>useContext</li>
</ul>
<p>设置 useStores 函数，⽤于在函数组件<br>内获取 context 对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import &#123; storesContext &#125; from &#x27;../contexts&#x27;;</span><br><span class="line">export const useStores = () =&gt; React.useContext(storesContext);</span><br></pre></td></tr></table></figure>

<ul>
<li>使⽤ context</li>
</ul>
<p>观察组件，通过 useStore 获取 context<br>对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &#x27;react&#x27;;</span><br><span class="line">import &#123; observer &#125; from &#x27;mobx-react&#x27;;</span><br><span class="line">import &#123; useStores &#125; from &#x27;../hooks/use-stores&#x27;;</span><br><span class="line">const About = observer(() =&gt; &#123;</span><br><span class="line"> const &#123; homeStore, aboutStore &#125; = useStores();</span><br><span class="line"> return (</span><br><span class="line"> &lt;div&gt;</span><br><span class="line"> &lt;h1&gt;About&lt;/h1&gt;</span><br><span class="line"> &lt;p&gt;current counter : &#123;aboutStore.counter&#125;&lt;/p&gt;</span><br><span class="line"> &lt;p&gt;home counter: &#123;homeStore.counter&#125;&lt;/p&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"> )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>参考</strong></p>
<ul>
<li><a href="https://cn.mobx.js.org/">mobx 中文文档</a></li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
</search>
